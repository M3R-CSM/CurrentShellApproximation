%------------------------------------------------------------------------%  
%   [Ir_1, Rr_1] = params_R(J_sol, L_sol, R1_sol, R2_sol)
%   solves for the ring paramters for 1 ring using the equations
%   defined by case R
%   case R equations [b1; Bz];
%
%   INPUTS
%   J_sol: J value for solenoid
%   L_sol: length of solenoid
%   R_1: inner radius of solenoid
%   R_2: outer radius of solenoid
%
%   OUTPUTS
%   I_1: current for ring 1
%   Rr_1: radius of ring 1
%
%   REMARKS
%   case R = [b1; Bz];
%   The optimal paramters of solved by using an LM algorithum
%
%   AUTHOR(S): Paige Husa
%
%   MODIFICATIONS: Brandon Saunders
%                  v1.0 4/29/2019
% ----------------------------------------------------------------------- %

function [Ir_1, Rr_1, soln_found] = params_R(J_sol, L_sol, R1_sol, R2_sol)
format long;
%% solenoid parameters
realS_J = J_sol; 
realS_L = L_sol; 
realS_R1 = R1_sol;
realS_R2 = R2_sol; 

delta_R = realS_R2 - realS_R1;
real_z = 0; 
real_mu = 1;%(4*pi)*1e-7;

c = c_vector_R(realS_J, realS_L, realS_R1, realS_R2, real_mu, real_z);

%% inputs to LM function
ravg = (realS_R2+realS_R1)/2;
rdiff = (realS_R2-realS_R1)/2;
radd = realS_R2 - ravg;
inGuess = ravg + radd/2;
outGuess = ravg - radd/2;

% gammaGuess = [realS_J*delta_R/2; realS_J*delta_R/2; inGuess; outGuess];
gammaGuess = [realS_J*delta_R*realS_L/1e7; ravg];
% gamma params I_1,Rr_1

tol = 1e-5; 

%basically runs forever unless solution is found or manually stopped
maxIterations = 100;
maxTime = 5000000000;
dispVals = 0;
maxChange = [];
cf = @costF;

%% LM method
[ currentEstimate, cost, soln_found ] = LM_LeastSquares( gammaGuess, @(x)cf(x,c), tol, maxIterations, maxTime, dispVals, maxChange );

if( any(currentEstimate <0 ))
    warning('Solution Found is non-physical. Resolving...');
    [ currentEstimate, cost, soln_found ] = LM_LeastSquares( abs(currentEstimate), @(x)cf(x,c), tol, maxIterations, maxTime, dispVals, maxChange );
    currentEstimate = abs(currentEstimate);
  
end

% currentEstimate
% cost

%% final values
Ir_1 = currentEstimate(1)*1e7;
Rr_1 = currentEstimate(2);

end

%% cost function
function [error, Jacobian] = costF(gammaGuess,c)
real_z = 0; 
real_mu = 1;%(4*pi)*1e-7;

f =              f_vector_R(gammaGuess(1)*1e7,  gammaGuess(2), real_mu, real_z);

J_gamma = jacobian_matrix_R(gammaGuess(1)*1e7,  gammaGuess(2), real_mu, real_z);

J_gamma(:,1) = J_gamma(:,1)*1e7;

Jacobian = J_gamma;

error = f -c;

error = error/norm(c);
Jacobian = Jacobian/norm(c);

%scale vlaues so no singularities
for i = 1:length(error)
   sc = norm(Jacobian(i,:));
   error(i) = error(i)/sc;
   Jacobian(i,:) = Jacobian(i,:)/sc;
end

end

%------------------------------------------------------------------------%  
%   c_1 = c_vector_R(J,Lsol,R1,R2,mu,z)
%   constants in equation (solenoid side of systme of equations) for case (R) where the
%   optimal solution is 1 ring
%
%   INPUTS
%   J: J value for solenoid
%   Lsol: length of solenoid
%   R1: inner radius of solenoid
%   R2: outer radius of solenoid
%   mu: magnetic permeability 
%   z: z location in solenoid (0 if at center - origin is at center)
%
%   OUTPUTS
%   c_1 = 2x1 vector of constants based on solenoid paramters for the 2
%   equations used in case R
%
%   REMARKS
%   equation solving for R case [b1; Bz;];
%
%   AUTHOR(S): Paige Husa
%
%   MODIFICATIONS: 
%                  v1.0 4/29/2019
% ----------------------------------------------------------------------- %

function c_1 = c_vector_R(J,Lsol,R1,R2,mu,z)
%C_VECTOR_R
%    C_1 = C_VECTOR_R(J,LSOL,R1,R2,MU,Z)

%    This function was generated by the Symbolic Math Toolbox version 8.2.
%    29-Apr-2019 19:59:15

t2 = R1.^2;
t3 = R2.^2;
t4 = Lsol.*z;
t5 = Lsol.^2;
t6 = t5./4.0;
t7 = z.^2;
t8 = t2+t4+t6+t7;
t9 = sqrt(t8);
t10 = R1+t9;
t11 = log(t10);
t12 = t3+t4+t6+t7;
t13 = sqrt(t12);
t14 = R2+t13;
t15 = log(t14);
t16 = t11-t15;
t17 = t2-t4+t6+t7;
t18 = sqrt(t17);
t19 = R1+t18;
t20 = log(t19);
t21 = t3-t4+t6+t7;
t22 = sqrt(t21);
t23 = R2+t22;
t24 = log(t23);
t25 = t20-t24;
c_1 = [J.*Lsol.*pi.*(R1.*t2-R2.*t3).*(-1.0./3.0);(mu.*(J.*Lsol.*t16.*pi+J.*Lsol.*t25.*pi+J.*t16.*z.*pi.*2.0-J.*t25.*z.*pi.*2.0).*(-1.0./4.0))./pi];
end

%------------------------------------------------------------------------%  
%   f_1 = f_vector_R(I_1,Rr_1,mu,z)
%   approx geometry side of system of equations with paramters for 
%   ring (case R)
%
%   INPUTS
%   I_1: current for ring
%   Rr_1: radius of ring 
%   mu: magnetic permeability 
%   z: z location in cylinders (0 if at center - origin is at center)
%
%   OUTPUTS
%   f1 = 2x1 vector of equations based on ring
%   paramters for the 2 equations used in case R
%
%   REMARKS
%   equations solving for R case [b1; Bz];
%
%   AUTHOR(S): Paige Husa
%
%   MODIFICATIONS: 
%                  v1.0 4/29/2019
% ----------------------------------------------------------------------- %

function f_1 = f_vector_R(I_1,Rr_1,mu,z)
%F_VECTOR_R
%    F_1 = F_VECTOR_R(I_1,RR_1,MU,Z)

%    This function was generated by the Symbolic Math Toolbox version 8.2.
%    29-Apr-2019 19:59:16

t2 = Rr_1.^2;
f_1 = [I_1.*t2.*pi;(I_1.*mu.*t2.*1.0./(t2+z.^2).^(3.0./2.0))./2.0];
end

%------------------------------------------------------------------------%  
%   Jacob1 = jacobian_matrix_R(I_1,Rr_1,mu,z)
%   equations for jacobian martix for case R
%
%   INPUTS
%   I_1: current for ring 
%   Rr_1: radius of ring 
%   mu: magnetic permeability 
%   z: z location in cylinders (0 if at center - origin is at center)
%
%   OUTPUTS
%   Jacob1 = 2x2 matrix of equations based on cylinderical shell and ring 
%   paramters for the 2 equations used in case R in f_vector and 
%   derivatives with respect to the 2 parameters
%
%   REMARKS
%   case RR equations [b1; Bz];
%   parameter order [I_1,Rr_1];
%
%   AUTHOR(S): Paige Husa
%
%   MODIFICATIONS: 
%                  v1.0 4/29/2019
% ----------------------------------------------------------------------- %

function Jacob1 = jacobian_matrix_R(I_1,Rr_1,mu,z)
%JACOBIAN_MATRIX_R
%    JACOB1 = JACOBIAN_MATRIX_R(I_1,RR_1,MU,Z)

%    This function was generated by the Symbolic Math Toolbox version 8.2.
%    29-Apr-2019 19:59:16

t2 = Rr_1.^2;
t3 = z.^2;
t4 = t2+t3;
t5 = 1.0./t4.^(3.0./2.0);
Jacob1 = reshape([t2.*pi,(mu.*t2.*t5)./2.0,I_1.*Rr_1.*pi.*2.0,I_1.*Rr_1.*mu.*t5-I_1.*Rr_1.*mu.*t2.*1.0./t4.^(5.0./2.0).*(3.0./2.0)],[2,2]);
end